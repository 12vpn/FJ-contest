# frog
直接跳过前19260817个字符，读入n、m，再跳到第n个字节，输出m-n个字节即可。当然也可以读取两次文件，第一次读取n、m，第二次读取的同时输出字符串。
# money
求最小表示法，再将数列哈希存进哈希表即可。
# river
正解是求导，直接求最值即可。三分精度太难了。
找规律就不详细说了。答案是v/sqrt(1-v*v)。
# tips
对于每个节点x，先处理出anc[x][y]，表示x的2^y祖先，再处理出lp[x][y]，表示所有在x的右边的深度为deep[x]+2^y的节点中最靠左的一个，rp[x][y]，表示所有在x的左边的深度为deep[x]+2^y的节点中最靠右的一个。lp与rp可以来自子树，也可以来自其他深度相同的节点的子树，优先选子树，没有再从旁边继承。由于出题人比较懒，直接把每个节点的儿子按照儿子的子树中深度最大的节点的深度排序，这样rp就只用从子树中继承了。按照bfs顺序给节点编号。每次发钱操作，通过类似于倍增求lca的方法求出x的子树中深度符合要求的节点中bfs顺序最大和最小的，再用树状树组差分区间加即可，每次查询时，输出所对应bfs顺序的前缀和即可。